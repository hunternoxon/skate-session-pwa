<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Brainlock Inline + Beta</title>
<style>
:root{--bg:#0b0b0c;--card:#141416;--muted:#8a8e93;--text:#f3f4f6;--accent:#0ea5e9;--ok:#22c55e;--bad:#ef4444;--ghost:#1c1d20;--border:#222327}
*{box-sizing:border-box}html,body{height:100%}body{margin:0;background:var(--bg);color:var(--text);font:16px -apple-system,system-ui,Segoe UI,Roboto,Inter,Arial,sans-serif;line-height:1.35}
.hidden{display:none!important}
.topbar{position:sticky;top:0;z-index:7;display:grid;grid-template-columns:1fr auto;align-items:center;gap:8px;padding:8px 12px;border-bottom:1px solid var(--border);background:rgba(11,11,12,.85);backdrop-filter:blur(8px)}
.brand-left{font-weight:800;letter-spacing:.2px;margin:0;cursor:pointer;font-size:18px;line-height:1.2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.icon{font-size:18px}
.ghost,.primary,.success,.danger{border-radius:9999px;font-weight:800}
.ghost{background:var(--ghost);color:var(--text);border:1px solid var(--border);padding:10px 12px}
.primary{background:#fff;color:#0b0b0c;border:1px solid #fff;padding:14px 18px}
.success{background:var(--ok);color:#051507;border:none;padding:14px 18px}
.danger{background:var(--bad);color:#160203;border:none;padding:14px 18px}
.card{margin:16px;padding:16px;border:1px solid var(--border);border-radius:16px;background:var(--card)}
.sheet{position:fixed;left:0;right:0;bottom:0;z-index:3;border-top-left-radius:18px;border-top-right-radius:18px;margin:0;padding:16px;background:var(--card);max-height:58vh;overflow:auto;padding-bottom:calc(env(safe-area-inset-bottom) + 28px)}
.letters-sheet{display:flex;justify-content:center;gap:0.8ch}
.letters-sheet>span{font-weight:900;font-size:clamp(26px,9vw,48px);color:#7f858c}
.letters-sheet>span.lost{color:#ffffff}
.scoreline{font-weight:700}
.hero-emoji{font-size:42px;opacity:.9;text-align:center;margin:8px 0 14px}
.trick.bigtitle{font-size:28px;font-weight:800;padding:16px;background:#101215;border:1px dashed var(--border);border-radius:14px;min-height:72px;display:flex;flex-direction:column;gap:10px}
.trick-topline{display:flex;justify-content:space-between;align-items:center}
.badge{font-size:12px;color:#cbd5e1;background:#0b0c0e;border:1px solid var(--border);padding:4px 8px;border-radius:9999px}
.actions{display:flex;gap:12px;justify-content:flex-end;margin:16px 0;flex-wrap:wrap}
.sheet-actions{display:flex;justify-content:flex-start;margin-top:8px}
.row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.foot{padding:16px;color:var(--muted);border-top:1px solid var(--border)}
/* Modals */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:10}
.modal.hidden{display:none !important;pointer-events:none !important}
.modal-card{background:#141416;border:1px solid var(--border);border-radius:16px;max-width:820px;width:92vw;padding:0;max-height:88vh;display:flex;flex-direction:column;overflow:hidden}
.modal-header,.modal-footer{display:flex;align-items:center;justify-content:center;gap:8px;padding:10px 12px;border-bottom:1px solid var(--border)}
.pane{padding:14px;overflow:auto;max-height:70vh}
/* Tricks overlay hierarchy */
.list{display:flex;flex-direction:column;gap:8px}
.list label.cat{font-size:28px;font-weight:900;padding:12px 14px;background:#101215;border:1px solid #2a2b2f;display:block;margin:10px 0 8px 0;border-radius:14px}
.list input[type="checkbox"].cat{transform:scale(1.6)}
.list .sub{margin:8px 0 20px 16px;border-left:2px solid #232429;padding-left:12px}
.list .sub label{font-size:14px;font-weight:600;background:#0e0f11;border:1px solid #1f2024;border-radius:12px;padding:8px 10px}
.small{font-size:12px;color:#9aa0a6}
hr.sep{border:none;border-top:1px solid #232429;margin:12px 0}
</style>
</head>
<body>
<header class="topbar">
  <h1 id="titleText" class="brand-left">Brainlock Inline + Beta</h1>
  <button id="dbgBtn" class="ghost icon" aria-label="Debug">DBG</button>
</header>

<main id="screen">
  <section class="card sheet" id="sheet">
    <div class="sheet-header">
      <div id="letters" class="letters-sheet"><span>S</span><span>K</span><span>A</span><span>T</span><span>E</span></div>
      <div id="scoreLine" class="scoreline">High Score: <button id="openHigh" class="ghost">0 pts</button></div>
    </div>

    <div id="viewSetup" class="view">
      <div class="hero-emoji">ðŸ§  ðŸ”’ ðŸ›¹</div>
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <div class="small">Game options (tap gear)</div>
        <button id="openOptions" class="ghost">âš™ï¸Ž</button>
      </div>
      <button id="startBtn" class="primary xl full start-cta">Start Session</button>
    </div>

    <div id="viewGame" class="view hidden">
      <div id="trick" class="trick bigtitle">
        <div class="trick-topline">
          <span id="attemptBadge" class="badge">Attempt 1/3</span>
          <button id="openAttempt" class="badge right as-link">This attempt: â€”</button>
        </div>
        <div id="trickText">â€”</div>
      </div>

      <div class="actions right" id="actionRow">
        <button id="skipBtn" class="ghost xl">Skip</button>
        <button id="missBtn" class="danger xl">Miss</button>
        <button id="landBtn" class="success xl">Land</button>
        <button id="nextBtn" class="primary xl hidden">Next</button>
      </div>

      <div class="sheet-actions">
        <button id="endBtn" class="ghost lg left">End Session</button>
      </div>
    </div>

    <div id="viewOver" class="view hidden">
      <div class="hero-emoji">ðŸ§  ðŸ”’ ðŸ›¹</div>
      <div class="row" style="justify-content:space-between">
        <div class="big">Final: <span id="finalScore">0 pts</span></div>
        <div class="big right">High: <button id="openHigh2" class="ghost">0 pts</button></div>
      </div>
      <button id="restartBtn" class="primary xl full">New Session</button>
    </div>
  </section>
</main>

<footer class="foot">v0.5.6-inline+beta â€¢ Updated: 2025-08-13</footer>

<!-- Modals -->
<div id="optionsModal" class="modal hidden" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-header"><h3>Game Options</h3></div>
    <div class="pane">
      <div class="list">
        <label class="cat"><input class="cat" type="checkbox" id="betaToggle"/> Use Beta Scoring & Selector</label>
        <div class="small">Default OFF (stable). Toggle ON to try the tuned difficulty spread, obstacle-aware selector, and repetition/flow rules.</div>
        <hr class="sep"/>
        <label class="cat">Obstacles</label>
        <div class="grid2" id="obsGrid"></div>
        <hr class="sep"/>
        <label class="cat">Stances</label>
        <div class="row" id="stanceRow"></div>
        <hr class="sep"/>
        <label class="cat">Trick Categories</label>
        <div class="row" id="catRow"></div>
        <div class="list sub" id="subcats"></div>
      </div>
    </div>
    <div class="modal-footer"><button id="closeOptions" class="ghost">X</button></div>
  </div>
</div>

<div id="overlay" class="modal hidden" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-header"><h3 id="modalTitle">Overlay</h3></div>
    <div id="modalBody" class="pane"></div>
    <div class="modal-footer"><button id="modalClose" class="ghost">X</button></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded',()=>{
  // Hard-hide modals
  ['optionsModal','overlay'].forEach(id=>{const m=document.getElementById(id); if(m){m.classList.add('hidden');m.setAttribute('aria-hidden','true')}});

  // Elements
  const $=id=>document.getElementById(id);
  const els={
    dbgBtn:$('dbgBtn'), startBtn:$('startBtn'),
    viewSetup:$('viewSetup'), viewGame:$('viewGame'), viewOver:$('viewOver'),
    trickText:$('trickText'), attemptBadge:$('attemptBadge'),
    nextBtn:$('nextBtn'), skipBtn:$('skipBtn'), missBtn:$('missBtn'), landBtn:$('landBtn'),
    scoreLine:$('scoreLine'), letters:$('letters'),
    endBtn:$('endBtn'), restartBtn:$('restartBtn'), finalScore:$('finalScore'),
    openOptions:$('openOptions'), optionsModal:$('optionsModal'), closeOptions:$('closeOptions'),
    betaToggle:$('betaToggle'),
    obsGrid:$('obsGrid'), stanceRow:$('stanceRow'), catRow:$('catRow'), subcats:$('subcats'),
    openAttempt:$('openAttempt'), overlay:$('overlay'), modalClose:$('modalClose'), modalTitle:$('modalTitle'), modalBody:$('modalBody')
  };

  function setNextVisible(on){ els.nextBtn.classList.toggle('hidden', !on); [els.skipBtn,els.missBtn,els.landBtn].forEach(b=>b.classList.toggle('hidden', on)); }

  // State
  const STATE={ level:5, beta:false,
    obstacles:{flat:true, ledge:true, rail:true, handrail:false, gap:false, hubba:false, kicker:false, quarterpipe:false, bank:false, stair:false},
    stances:{regular:true,fakie:true,nollie:true,switch:false},
    cats:{flips:true, grinds:true, manuals:false, spins:true, airs:false},
    sub:{ flips:{"kickflip":true,"heelflip":true,"varial kickflip":true,"hardflip":true,"tre flip":true},
           grinds:{"50-50":true,"5-0":true,"boardslide":true,"noseslide":true,"tailslide":true,"smith":true,"feeble":true,"crooked":true,"nosegrind":true,"bluntslide":true,"noseblunt":true},
           spins:{"180":true,"360":true},
           manuals:{"manual":true},
           airs:{} }
  };

  // UI builders
  const OB_ALL=[["flat","Flat"],["ledge","Ledge"],["hubba","Hubba"],["rail","Rail"],["handrail","Handrail"],["gap","Gap"],["kicker","Kicker"],["quarterpipe","Quarter"],["bank","Bank"],["stair","Stairs"]];
  function buildObs(){ els.obsGrid.innerHTML = OB_ALL.map(([k,l])=>`<label><input type="checkbox" data-obs="${k}" ${STATE.obstacles[k]?'checked':''}/> ${l}</label>`).join(''); }
  function buildStances(){ const order=["regular","fakie","nollie","switch"]; els.stanceRow.innerHTML=order.map(k=>`<label><input type="checkbox" data-stance="${k}" ${STATE.stances[k]?'checked':''}/> ${k}</label>`).join(''); }
  function buildCats(){ const keys=[["flips","Flip Tricks"],["grinds","Grinds/Slides"],["manuals","Manuals"],["spins","Spins"],["airs","Airs"]]; els.catRow.innerHTML = keys.map(([k,l])=>`<label class="cat"><input class="cat" type="checkbox" data-cat="${k}" ${STATE.cats[k]?'checked':''}/> ${l}</label>`).join(''); buildSubcats(); }
  function buildSubcats(){
    const blocks=[];
    if(STATE.cats.flips) blocks.push(['flips', ["kickflip","heelflip","varial kickflip","hardflip","tre flip"]]);
    if(STATE.cats.grinds) blocks.push(['grinds', ["50-50","5-0","boardslide","noseslide","tailslide","smith","feeble","crooked","nosegrind","bluntslide","noseblunt"]]);
    if(STATE.cats.spins) blocks.push(['spins', ["180","360"]]);
    if(STATE.cats.manuals) blocks.push(['manuals', ["manual"]]);
    els.subcats.innerHTML = blocks.map(([k,arr])=>`<div class="sub">${arr.map(name=>`<label><input type="checkbox" data-sub="${k}" data-name="${name}" ${STATE.sub[k][name]?'checked':''}/> ${name}</label>`).join(' ')}</div>`).join('');
  }

  // Wire options
  els.openOptions.addEventListener('click',()=>{ els.optionsModal.classList.remove('hidden'); els.optionsModal.setAttribute('aria-hidden','false'); });
  els.closeOptions.addEventListener('click',()=>{ els.optionsModal.classList.add('hidden'); els.optionsModal.setAttribute('aria-hidden','true'); });
  els.betaToggle.addEventListener('change', e=> STATE.beta = !!e.target.checked);
  els.obsGrid.addEventListener('change', e=>{ const k=e.target.getAttribute('data-obs'); STATE.obstacles[k]=e.target.checked; });
  els.stanceRow.addEventListener('change', e=>{ const k=e.target.getAttribute('data-stance'); STATE.stances[k]=e.target.checked; });
  els.catRow.addEventListener('change', e=>{ const k=e.target.getAttribute('data-cat'); STATE.cats[k]=e.target.checked; buildSubcats(); });
  els.subcats.addEventListener('change', e=>{ const k=e.target.getAttribute('data-sub'); const n=e.target.getAttribute('data-name'); STATE.sub[k][n]=e.target.checked; });

  // Trick describe helpers
  function stancePool(){ return Object.entries(STATE.stances).filter(([k,v])=>v).map(([k])=>k) }
  function random(arr){ return arr[Math.floor(Math.random()*arr.length)] }
  function describe(c){
    const parts=[];
    if(c.stance && c.stance!=='regular') parts.push(c.stance);
    if(c.spin) parts.push(c.spin);
    if(c.flip) parts.push(c.flip);
    if(c.grind) parts.push((c.direction?c.direction+' ':'')+c.grind);
    if(c.manual) parts.push(c.manual);
    parts.push('on', c.obstacle||'flat');
    return parts.join(' ').replace(/\s+/g,' ').trim();
  }

  // Baseline (stable) generator
  function genStable(){
    const obsKeys = Object.keys(STATE.obstacles).filter(k=>STATE.obstacles[k]);
    const obstacle = obsKeys.length ? random(obsKeys) : 'flat';
    const stance = random(stancePool())||'regular';
    const useFlip = STATE.cats.flips && Math.random()<0.8;
    const useGrind = STATE.cats.grinds && (obstacle==='rail'||obstacle==='handrail'||obstacle==='ledge'||obstacle==='hubba') && Math.random()<0.7;
    const useManual = STATE.cats.manuals && (obstacle==='flat'||obstacle==='bank') && Math.random()<0.3;
    const spin = (STATE.cats.spins && Math.random()<0.25 && STATE.sub.spins['180']) ? (Math.random()<0.6?'180':'360') : null;
    const flip = useFlip ? random(Object.keys(STATE.sub.flips).filter(k=>STATE.sub.flips[k])) : null;
    let grind=null, direction=null;
    if(useGrind){
      const g = Object.keys(STATE.sub.grinds).filter(k=>STATE.sub.grinds[k]);
      grind = g.length?random(g):null;
      direction = ['frontside','backside'][Math.floor(Math.random()*2)];
    }
    const manual = useManual? 'manual' : null;
    if(grind && !(obstacle==='rail'||obstacle==='handrail'||obstacle==='ledge'||obstacle==='hubba')) grind=null;
    return { obstacle, stance, spin, flip, grind, direction, manual };
  }

  // Beta generator: obstacle-aware simplified
  const OB_OK = {
    grind: new Set(['rail','handrail','ledge','hubba']),
    air: new Set(['flat','gap','kicker','bank','quarterpipe','stair']),
    manualOk: new Set(['flat','bank'])
  };

  function genBeta(){
    const obsKeys = Object.keys(STATE.obstacles).filter(k=>STATE.obstacles[k]);
    const obstacle = obsKeys.length ? random(obsKeys) : 'flat';
    const stance = random(stancePool())||'regular';
    let spin=null; const lvl=STATE.level||5;
    const spinRoll = Math.random();
    if(STATE.cats.spins){
      if(lvl<=3 && spinRoll<0.08) spin = '180';
      else if(lvl<=6 && spinRoll<0.28) spin = (Math.random()<0.6?'180':'360');
      else if(lvl>=7 && spinRoll<0.5)  spin = (Math.random()<0.5?'180':'360');
    }
    let flip=null, grind=null, direction=null, manual=null;
    const flipsAvail = Object.keys(STATE.sub.flips).filter(k=>STATE.sub.flips[k]);
    const grindsAvail = Object.keys(STATE.sub.grinds).filter(k=>STATE.sub.grinds[k]);
    const wantFlip = STATE.cats.flips && flipsAvail.length>0;
    const wantGrind = STATE.cats.grinds && grindsAvail.length>0 && OB_OK.grind.has(obstacle);
    const wantManual = STATE.cats.manuals && OB_OK.manualOk.has(obstacle);
    const patterns=[];
    if(wantGrind) patterns.push('grindOnly');
    if(wantGrind && wantFlip) patterns.push('flipToGrind');
    if(wantFlip && OB_OK.air.has(obstacle)) patterns.push('flipOnly');
    if(wantManual) patterns.push('manualOnly');
    if(patterns.length===0) patterns.push(wantFlip?'flipOnly':'grindOnly');
    const pat = random(patterns);
    if(pat==='flipOnly') flip = random(flipsAvail);
    if(pat==='grindOnly'){ grind = random(grindsAvail); direction = Math.random()<0.5?'frontside':'backside'; }
    if(pat==='flipToGrind'){ flip = random(flipsAvail); grind = random(grindsAvail); direction = Math.random()<0.5?'frontside':'backside'; }
    if(pat==='manualOnly') manual='manual';
    if(grind && !OB_OK.grind.has(obstacle)) grind=null;
    if(flip && !grind && !OB_OK.air.has(obstacle) && obstacle!=='flat') flip=null;
    return { obstacle, stance, spin, flip, grind, direction, manual };
  }

  // Scoring (beta only; stable uses flat 200 per land)
  const SC = {
    flipBase: {"kickflip":200,"heelflip":220,"varial kickflip":280,"hardflip":340,"tre flip":360},
    grindBase: {"50-50":220,"5-0":260,"boardslide":230,"noseslide":240,"tailslide":270,"smith":340,"feeble":360,"crooked":340,"nosegrind":360,"bluntslide":420,"noseblunt":460},
    manualBase: {"manual":200},
    stance: {"regular":1.00,"fakie":1.20,"nollie":1.25,"switch":1.25},
    spin: {"0":1.00,"180":1.10,"360":1.30},
    obstacle: {"flat":1.00,"ledge":1.20,"hubba":1.30,"rail":1.40,"handrail":1.70,"gap":1.50,"kicker":1.10,"bank":1.10,"quarterpipe":1.20,"stair":1.50},
    dir: {"smith":{frontside:1.10,backside:1.20},"feeble":{frontside:1.15,backside:1.05},"crooked":{frontside:1.12,backside:1.06},"bluntslide":{frontside:1.20,backside:1.15},"noseblunt":{frontside:1.25,backside:1.20},"50-50":{frontside:1.00,backside:1.00},"5-0":{frontside:1.05,backside:1.05},"boardslide":{frontside:1.00,backside:1.05},"noseslide":{frontside:1.00,backside:1.05},"tailslide":{frontside:1.05,backside:1.10}},
    attempt: {1:1.00,2:0.85,3:0.75},
    combo: {flipIn:1.25, spinFlip:1.30, spinIntoGrind:1.15, manualCombo:1.10},
    flowPer:0.03, flowCap:1.15
  };
  let STREAK=0;
  const seen={}; // repetition tracker

  function computeStable(){ return {final:200, breakdown:[["flat","â€”","Ã—1.0"]]}; }

  function computeBeta(c,att){
    let pts=0; const bd=[];
    const stance=c.stance||'regular', obstacle=c.obstacle||'flat', spin=c.spin||'0';
    if(c.flip){ const b=SC.flipBase[c.flip]||200; pts+=b; bd.push(['flip',c.flip,b]); }
    if(c.grind){ const b=SC.grindBase[c.grind]||240; pts+=b; bd.push(['grind',c.grind,b]); const dm=SC.dir[c.grind]&&SC.dir[c.grind][c.direction||'frontside']; if(dm){ pts*=dm; bd.push(['direction',c.direction,'Ã—'+dm]); } }
    if(c.manual){ const b=SC.manualBase[c.manual]||180; pts+=b; bd.push(['manual',c.manual,b]); }
    const om=SC.obstacle[obstacle]||1; pts*=om; bd.push(['obstacle',obstacle,'Ã—'+om]);
    const sm=SC.stance[stance]||1; pts*=sm; bd.push(['stance',stance,'Ã—'+sm]);
    const spm=SC.spin[spin]||1; if(spm!==1){ pts*=spm; bd.push(['spin',spin,'Ã—'+spm]); }
    let combo=1.0;
    if(c.flip && c.grind) combo*=SC.combo.flipIn;
    if(c.flip && c.spin)  combo*=SC.combo.spinFlip;
    if(c.spin && c.grind) combo*=SC.combo.spinIntoGrind;
    if(c.manual && (c.flip||c.spin)) combo*=SC.combo.manualCombo;
    if(combo!==1){ pts*=combo; bd.push(['combo','â€”','Ã—'+combo]); }
    const attm=SC.attempt[att]||1; pts*=attm; bd.push(['attempt','x'+att,'Ã—'+attm]);
    const flow=Math.min(1+STREAK*SC.flowPer, SC.flowCap); if(flow!==1){ pts*=flow; bd.push(['flow',STREAK+' streak','Ã—'+flow.toFixed(2)]) }
    const sig=[stance,spin,c.flip||'',c.grind||c.manual||'',c.direction||'',obstacle].join('|');
    seen[sig]=(seen[sig]||0)+1;
    if(seen[sig]>=3){ const reps=seen[sig]-2; const pen=Math.max(0.0, 1-0.10*reps); pts*=pen; bd.push(['repeat', '#'+seen[sig], 'Ã—'+pen.toFixed(2)]) }
    return {final:Math.max(1, Math.round(pts)), breakdown:bd};
  }

  // Flow
  let misses=0,total=0,attempt=1,current=null;
  function updateLetters(){ [...els.letters.children].forEach((s,i)=> s.classList.toggle('lost', i<misses)); }
  function setView(v){
    els.viewSetup.classList.toggle('hidden', v!=='setup');
    els.viewGame.classList.toggle('hidden', v!=='game');
    els.viewOver.classList.toggle('hidden', v!=='over');
    if(v==='setup') els.scoreLine.innerHTML = 'High Score: <button class="ghost">0 pts</button>';
    if(v==='game')  els.scoreLine.textContent = 'Total Score: '+ total +' pts';
  }

  function nextTrick(){
    attempt=1;
    current = STATE.beta ? genBeta() : genStable();
    els.trickText.textContent = describe(current);
    els.attemptBadge.textContent = 'Attempt 1/3';
    setNextVisible(false);
    els.skipBtn.disabled=false;els.missBtn.disabled=false;els.landBtn.disabled=false;
  }

  function settle(hit){
    if(hit){
      STREAK++;
      const rep = STATE.beta ? computeBeta(current,attempt) : computeStable();
      total += rep.final;
      els.scoreLine.textContent = 'Total Score: ' + total + ' pts';
      setNextVisible(true);
      els.skipBtn.disabled=true;els.missBtn.disabled=true;els.landBtn.disabled=true;
    }else{
      if(attempt<3){ attempt++; els.attemptBadge.textContent='Attempt '+attempt+'/3'; }
      else{ STREAK=0; misses++; updateLetters(); setNextVisible(true); els.skipBtn.disabled=true;els.missBtn.disabled=true;els.landBtn.disabled=true; }
    }
  }

  // Wire
  els.dbgBtn.addEventListener('click',()=>alert('JS live inline + beta'));
  els.startBtn.addEventListener('click',()=>{ misses=0; total=0; attempt=1; updateLetters(); setView('game'); nextTrick(); buildObs(); buildStances(); buildCats(); });
  els.restartBtn.addEventListener('click',()=>{ setView('setup'); });
  els.endBtn.addEventListener('click',()=>{ setView('setup'); });
  els.skipBtn.addEventListener('click',()=>{ setNextVisible(false); nextTrick(); });
  els.missBtn.addEventListener('click',()=>settle(false));
  els.landBtn.addEventListener('click',()=>settle(true));
  // Attempt breakdown viewer (placeholder)
  els.openAttempt.addEventListener('click',()=>{ els.modalTitle.textContent='Attempt Score Breakdown'; els.modalBody.innerHTML='<div class="small">Detailed breakdown shows when Beta is ON and you land.</div>'; els.overlay.classList.remove('hidden'); });
  els.modalClose.addEventListener('click',()=>{ els.overlay.classList.add('hidden'); });

  // Build initial options
  buildObs(); buildStances(); buildCats();
  setView('setup'); updateLetters();
});
</script>
</body>
</html>
